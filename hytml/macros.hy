#!/usr/bin/python3

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;(html*
;  (!DOCTYPE html)
;  (html :lang 'en 
;    (head (title "Page title"))
;    (body
;      (!-- " Body part starts from here... ")
;      (div :class "main-container"
;         (h1 ~(.upper "Page content"))
;         (table (tr (for-each [i [1 2 3]] `(td ~i))))))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(import (hytml.specs (specs)))

(eval-and-compile
  
  ; helper macro
  (defmacro defgets [name if-code]
    `(defn ~name [code]
      (setv items [] key None)
      (for [item code]
           (do 
             ~if-code
             (if (keyword? item)
                 (setv key item)
                 (setv key None))))
      items))
  
  ; get attributes from argument set.
  ; every other item could be a key and value. for example
  ; "content" :key value "more content" :key2 value2
  ; returns [(, key value) (, key2 value2)]
  (defgets get-attributes
    (if-not (none? key)
            (.append items (, (.join "" (drop 2 key)) item))))

  ; get content from argument set.
  ; every other item could be a key and value. for example
  ; "content" :key value "more content" :key2 value2
  ; in this case only content is returned:
  ; ["content" "more content"]
  (defmacro defcontent [name parser]
    `(defgets ~name
      (if (and (none? key) (not (keyword? item))) 
          (.append items (if (coll? item) (~parser item) item)))))

  (defcontent get-content parse-html)

  (defcontent get-content4 parse-html4)
  
  (defmacro defgets+ [name if-code]
    `(defn ~name [code]
      (setv content []
            attributes []
            key None)
      (for [item code]
           (do 
             ~if-code
             (if (keyword? item)
                 (setv key item)
                 (setv key None))))
      (, content attributes)))
  
  (defmacro defget [name parser]
    `(defgets+ ~name
      (if-not (none? key)
              (if-not (keyword? item)
                      (.append attributes (, (.join "" (drop 2 key)) item)))
              (if-not (or (keyword? key) (keyword? item)) 
                      (.append content (if (coll? item) (~parser item) item))))))

  ; TODO: optimize content and attribute creation with one call:
  ; (get-content-attributes '(1 :k "x" 2 :l "y" 3))
  ; -> ([1, 2, 3], [('k', 'x'), ('l', 'y')])
  (defget get-content-attributes parse-html)

  (defget get-content-attributes4 parse-html4)

  ; main parser loop
  ; get-content function calls back here so that recursive
  ; generating becomes possible
  (defmacro defparse [name do-code]
    `(defn ~name [code]
      (if (coll? code)
      (do
        (setv tag (catch-tag (first code)))
        ; note: hy transforms - to _
        (if ; comment tag <!-- -->
            ; can be written as a plain text also: (body "<!-- comments... -->")
            ; actual notation looks a little bit silly: (!-- "comments")
            ; so this case is likely to be removed as a redundant case
            (= tag "!__")
            (+ "<!--" (tag-content (get-content (list (drop 1 code)))) "-->")
            ; doctype code block is special because tag content is placed inside start tag
            ; plus start tag is not in short form althought end tag is not rendered, which 
            ; is a little bit similar to col tag.
            ; (!DOCTYPE html) => <!DOCTYPE html>
            ; (!DOCTYPE note SYSTEM \"Note.dtd\") => <!DOCTYPE note SYSTEM "Note.dtd">
            ; this could also be generated by plain text, so these two cases might be an overkill..
            (= tag "!DOCTYPE")
            (+ "<!DOCTYPE " (tag-content (get-content (list (drop 1 code)))) ">")
            ; unquoting code. this means that one can change from html* macro mode
            ; to the normal lisp evaluation mode:
            ; (html* ~(+ 1 1)) -> (html* (unquote (+ 1 1)))
            ; unquote part of the code is untouched, but second part of  the code is evaluated
            ; thus becoming: (str (eval (+ 1 1))) -> "2"
            (= tag "unquote") (str (eval (second code)))
            ; ~@ is used to concat lists. parse-html function is called recursively 
            ; to evaluate the content. works similarly with unquote but in this case
            ; list of recursively parsed strings are joined together
            (= tag "unquote_splice") 
            (.join "" (map parse-html (eval (second code))))
            ; special for-each loop. ~@(list-comp) list compression could be used in place of this
            ; but for-each syntax may be more pleasing in some cases.
            ; for-each doesn't require using unquote splice combo syntax
            (= tag "for_each") (eval code)
            ~do-code))
      ; return code as a string because html is practically just a stream of text
      (str code))))
  
  (defparse parse-html
    ; normal tag, attribute, and content processing
    (do
      (setv content-code (list (drop 1 code)))
      (setv content (get-content content-code))
      ; empty content will give a short tag
      (+ (tag-start tag (get-attributes content-code) (empty? content))
         (if-not (empty? content)
                 (+ (tag-content content)(tag-end tag))
                  ""))))
  
  (defn tag? [tag] (in (keyword tag) specs))

  (defn tag-specs [tag] (get specs (keyword tag)))

  (defn omit? [tag] (get (tag-specs tag) :omit))

  (defn forbidden? [tag] (get (tag-specs tag) :forbidden))
  
  (defparse parse-html4
    ; normal tag, attribute, and content processing
    (do
      ; for some reason import in the beginning of the file
      ; or inside eval-and-compile doesn't work...
      (import (hytml.specs (specs)))
      (if (tag? tag)
          (do
            (setv content-code (list (drop 1 code)))
            (setv content (get-content content-code))
            ; empty content will give a short tag
            (+ (tag-start tag (get-attributes content-code) (empty? content) (omit? tag))
               (if (and (not (forbidden? tag)) (not (empty? content)))
                 (+ (tag-content content) (tag-end tag))
                  "")))
          (raise (Exception (% "Tag '%s' not meeting html4 specs" tag))))))
  
  ; create a tag from the first item of the expression
  ; first try to evaluate code, because there might be
  ; a calculated expression for the tag name, naive examples:
  ; "td" or (+ "t" "d") -> td
  ; but in case symbol td is used, it will raise a name errors
  ; which will cause that string representation of the symbol is
  ; returned on the except part
  (defn catch-tag [code]
    (try
      ; catch "'name' is not defined" errors
      (str (eval code))
      (except (e Exception)
        (eval 'code))))
  
  ; transforms [(key value)] list to xml attribute list:
  ; key="value". both key and value part will be evaluated
  ; so that calculated expressions can be used for them
  ; NOTE: do to get-attributes behaviour key doesn't really support
  ; calculated expressions. but for value naive example is:
  ; (if (even? ~i) "even" "odd")
  (defn concat-attributes [attr]
    (if-not (empty? attr)
       (+ " " (.join " " 
         (list-comp 
           (% "%s=\"%s\"" (, (str (eval 'key)) 
                             (if-not (empty? value) (str (eval value)) ""))) 
           [[key value] attr])))
        ""))

  (defn concat-content [content]
    (.join "" (map str content)))
  
  (defn tag-content [content]
    (if-not (none? content)
            (concat-content content)
             ""))

  (defn tag-start [name attr &optional [short False] [omit False]]
    (+ "<" name (concat-attributes attr) (if (and short (not omit)) "/>" ">")))

  (defn tag-end [name] (+ "</" name ">")))

; unicode Square Ml U+3396  is a shorthand for parsing tags. note that
; html* and similar macros will accept multiple expressions, not just
; an expression with a single root node
(defreader „éñ [code] (parse-html code))

; html* is xml* because it will accept any tags, 
; not just html4 or html5 tags
(defmacro html* [&rest code]
  (.join "" (map parse-html code)))

; strict set of html tag generator for html4
(defmacro html4 [&rest code]
  (.join "" (map parse-html4 code)))

(defmacro xml* [&rest code]
  (.join "" (map parse-html code)))

; xhtml is almost same as html4 and html5 but tags must be correctly closed
; for example <b> must be <b/> in xhtml
(defmacro xhtml* [&rest code]
  (.join "" (map parse-html code)))

; strict set of html tag generator for html5
(defmacro html5 [&rest code] "Not implemented.")

(defmacro for-each [args code]
  `(eval `(html* ~@(list-comp ~code ~args))))
